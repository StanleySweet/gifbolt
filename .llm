---
model:claude-haiku-4.5
---
# GifBolt Standards

MANDATORY code standards for GifBolt. All violations=ERRORS; zero warnings policy enforced via .editorconfig, analyzers.

## C# (MANDATORY)

**Naming(ERROR):** Types/Interfaces=PascalCase(I prefix for interfaces); Public=PascalCase; Private=_camelCase; Locals/Params=camelCase
Ex: `GifBoltControl:Control{private IntPtr _nativeHandle; public string Source{get;set;} public bool LoadGif(string path){var result=false; return result;}}` `IGifDecoder{void Decode();}`

**this(ERROR):** MUST use explicit `this.` for fields/properties/methods/events. ✓:`if(this._isLoaded)return; this.Source="x"; this.Method();` ✗:`if(_isLoaded)` or `Source=` or `Method()`

**sealed(ERROR):** Classes=sealed unless designed for inheritance. ✓:`public abstract class Base{abstract void Play();} public sealed class Impl:Control{}` ✗:`public class Impl:Control{}`

**File Headers(MANDATORY):** ALL C# files must begin with copyright/license XML comment block. Format:
```
// <copyright file="FileName.cs" company="GifBolt Contributors">
// Copyright (c) 2026 GifBolt Contributors. All rights reserved.
// Licensed under the MIT License. See LICENSE file in the project root for full license information.
// </copyright>
// SPDX-License-Identifier: MIT
// SPDX-FileCopyrightText: 2026 GifBolt Contributors
```

**Docs(MANDATORY):** ALL public classes/interfaces/methods/properties/fields require XML docs w/ `<summary>`,`<remarks>`,`<param>`,`<returns>`,`<exception>`. Format: `///<summary>Brief desc</summary>///<remarks>Context</remarks>///<param name="x">Desc</param>///<returns>Result</returns>///<exception cref="T">When</exception>`. Private: brief comments explaining purpose.

**Braces:** Allman style(new line); braces for all blocks(even single-line). Ex: `class X{\n public bool M(){\n if(x){\n return false;\n }\n return true;\n }\n}`

**Order:** Using→Namespace→Class+docs→Constants/statics→Fields(priv,pub)→Props(priv,pub)→Ctors→Public methods→Private methods→Nested types

**Misc:** Line<120chars; 4spaces; ArgumentNullException for nulls; Async suffix; IEnumerable<T> over List<T> in APIs; $"interpolation" over Format()

**Config:** .editorconfig=source of truth(severity: error=build fail; warning=warn; suggestion=hint; silent=none). Static analysis via Roslyn; formatting via EditorConfig+pre-commit; docs analyzed.

---

## C++ (MANDATORY)

**ZERO WARNINGS POLICY**: All compiler/static analysis warnings=ERRORS; must resolve before commit.

**Format:** .clang-format w/ Google style(Allman braces); 4spaces; line<100chars; space before parens in control statements
Ex: `class GifDecoder{\npublic:\n bool Decode(const std::string& path){\n if(path.empty()){\n return false;\n }\n return true;\n }\nprivate:\n std::vector<Frame> _frames;\n size_t _currentFrame;\n};`

**Naming:** Classes/Structs=PascalCase; Functions=camelCase; Members=_camelCase(underscore prefix); Constants=UPPER_SNAKE_CASE; Locals=camelCase; Macros=UPPER_SNAKE_CASE
Ex: `class GifRenderer{private: ID3D11Device* _device; static const size_t MAX_FRAMES=1024; public: void renderFrame(size_t frameIndex){}};`

**Docs:** All public classes/functions require C++ style docs: `///\brief Desc.\n///\param x Param desc.\n///\return Return desc.\n///\throws Exception When.` `///\class Name\n///\brief Brief.\n///\details Details.`

**Static Analysis:** Must pass .clang-tidy w/ NO WARNINGS. Memory safety; RAII; no unnecessary copies; use refs; C++17 features; clear names; no magic numbers.

**Compiler:** MUST compile w/ `-Wall -Wextra -Wpedantic -Werror` and ZERO warnings. No unused vars; no signed/unsigned mismatch; no shadowed vars; braces for all; explicit casts.

**Memory:** Use smart ptrs(`std::unique_ptr`,`std::shared_ptr`) for dynamic alloc; RAII for resources; avoid raw ptrs in APIs; doc ownership semantics.
✓:`std::unique_ptr<GifDecoder> CreateDecoder(){return std::make_unique<GifDecoder>();}` ✗:`GifDecoder* CreateDecoder(){return new GifDecoder();}`

---

## Project Management (MANDATORY)

**.csproj Optimization:** SDK-style format:`<Project Sdk="Microsoft.NET.Sdk">`; remove unnecessary props/items; rely on SDK defaults; only explicit PackageReference/ProjectReference when needed; no redundant file listings(SDK globs); no auto-gen metadata comments.
Optimal: `<Project Sdk="Microsoft.NET.Sdk"><PropertyGroup><TargetFramework>net6.0</TargetFramework><Nullable>enable</Nullable></PropertyGroup><ItemGroup><PackageReference Include="Avalonia" Version="11.0.0"/></ItemGroup><ItemGroup><ProjectReference Include="..\GifBolt.Core\GifBolt.Core.csproj"/></ItemGroup></Project>`
Avoid: OutputType/RootNamespace/AssemblyName props(SDK infers); explicit Compile items(SDK includes all .cs automatically)

**Repo Structure:** DO NOT create temp/versioned folder names. NO: `_new`,`_old`,`_backup`,`_temp`,date suffixes. Repo=Git; modify in-place; use branches for experiments; use Git history for old versions; move/rename w/ Git commands.
✗:`docs/`,`docs_new/`,`src_backup/` ✓:`docs/`,`src/`(modify in-place; use Git branches)
If restructure needed: `git checkout -b refactor/name`; make changes in orig folders; commit w/ clear msgs; merge when ready.

---

## For LLM Agents

**C# Review:** (1)Always apply rules-non-negotiable; (2)Check .editorconfig first; (3)Add Doxygen comments to all public APIs immediately; (4)Use explicit `this` for all member access; (5)Mark classes `sealed` unless inheritance needed; (6)Follow Allman brace style; (7)PascalCase for public,camelCase for params/locals; (8)_camelCase for private fields; (9)Keep .csproj minimal; (10)Never create "_new" or temp folder structures. Flag violations as errors. NO warnings acceptable.

**C++ Review:** (1)Always apply rules-non-negotiable; (2)Check .clang-format/.clang-tidy first; (3)Add docs to all public APIs; (4)Use smart pointers-never raw ptrs in new APIs; (5)Follow naming conventions-PascalCase classes,camelCase functions; (6)_camelCase for members; (7)Write code passing `-Wall -Wextra -Wpedantic -Werror`. Flag ALL warnings as errors. Zero tolerance.

---

## Project Structure

```
src/
├── GifBolt.Core/          # Cross-platform core(netstandard2.0)
│   └── GifPlayer.cs       # Core player facade
├── GifBolt.Wpf/           # WPF platform wrapper
│   └── GifBoltControl.cs  # WPF control
└── GifBolt.Native/        # C++ DirectX renderer
    ├── CMakeLists.txt
    ├── include/
    └── src/
```

---

## Development Workflow

### C++ Development

**Building:**
```bash
# Build all C++ native libraries (Debug/Release)
cmake --build build
cmake --build build --config Release

# Rebuild from scratch
rm -rf build && cmake -B build && cmake --build build
```

**After C++ Changes:**
1. Edit files in `src/GifBolt.Native/src/` or `src/GifBolt.Native/include/`
2. Run `cmake --build build` (automatically uses CMakeLists.txt)
3. C API exports updated → gifbolt_c.cpp/gifbolt_c.h reflect changes
4. Copy new dylib to C# projects: `cp build/src/GifBolt.Native/libGifBolt.Native.dylib samples/GifBolt.AvaloniaApp/bin/Release/net6.0/`

**Adding New Functions:**
1. Implement in C++: `GifDecoder.cpp` + `GifDecoder.h`
2. Export in C API: `gifbolt_c.h` (declare) + `gifbolt_c.cpp` (implement wrapper)
3. Expose in C#: `Native.cs` (delegate + GetDelegate call) + `GifPlayer.cs` (public method)
4. Always include XML docs for C++ public APIs (see Docs section)
5. Compile: `cmake --build build`

**Testing C++ Directly:**
Create inline debug programs to test C++ logic without C# layer:
```bash
# Example: inspect frame delays directly from dylib
clang++ -std=c++17 debug_gif_delays.cpp -o debug_gif_delays -ldl
./debug_gif_delays /path/to/animation.gif
```

**Debug Logging:**
Use `DebugLog()` function to capture debug output to both OutputDebugString and `%TEMP%\gifbolt_debug.log`.

Function signature:
```cpp
void DebugLog(const char* format, ...);
```

Usage:
```cpp
#include "Debug.h"  // or where DebugLog is declared

// Simple message
DebugLog("Initializing GPU texture");

// With values
DebugLog("[D3D9ExTexture::Update] Frame %d, DisplayingAlt=%d, Size=%zu bytes", frameIndex, alt, dataSize);

// In conditional blocks
if (!textureUpdateSucceeded) {
    DebugLog("ERROR: GPU texture update failed for frame %d", frameIndex);
}
```

Output locations:
- Visual Studio: View → Output → Debug window
- File: `%TEMP%\gifbolt_debug.log` (readable with `Get-Content $env:TEMP\gifbolt_debug.log`)

Reading logs after test run:
```powershell
Get-Content $env:TEMP\gifbolt_debug.log -Tail 50  # Last 50 lines
Get-Content $env:TEMP\gifbolt_debug.log | Select-String "ERROR"  # Filter to errors
```

### C# Development

**Building:**
```bash
# Build Core → Avalonia → Sample App (in dependency order)
dotnet build src/GifBolt.Core/GifBolt.Core.csproj -c Release
dotnet build src/GifBolt.Avalonia/GifBolt.Avalonia.csproj -c Release
dotnet build samples/GifBolt.AvaloniaApp/GifBolt.AvaloniaApp.csproj -c Release

# Build and run in one command
dotnet build src/GifBolt.Avalonia/GifBolt.Avalonia.csproj -c Release && \
  dotnet build samples/GifBolt.AvaloniaApp/GifBolt.AvaloniaApp.csproj -c Release && \
  /Users/stan/Dev/GifBolt/samples/GifBolt.AvaloniaApp/bin/Release/net6.0/GifBolt.AvaloniaApp
```

**After C# Changes:**
1. Edit `.cs` files (changes apply via hot-reload or rebuild)
2. If P/Invoke signatures changed → update `Native.cs` delegate declarations
3. Run `dotnet build` to verify no compilation errors
4. All style/naming violations flagged by .editorconfig (FIX BEFORE COMMIT)

**Adding New Native Methods:**
1. Implement in C++ with docs
2. Export via C API (`gifbolt_c.h` + `gifbolt_c.cpp`)
3. Add delegate in `Native.cs`: `private delegate TReturnType MethodName(TParam params);`
4. Load delegate: `private static readonly MethodName = ... GetDelegate<...>("gb_method_name");`
5. Create public wrapper in `GifPlayer.cs` with XML docs
6. Test by rebuilding and calling from C#

### Running Tests

**C++ Unit Tests (Catch2):**
```bash
# Run all C++ tests (from project root)
cd /Users/stan/Dev/GifBolt && ctest

# Run specific test file
build/tests/GifBolt.Tests GifDecoderTests.cpp

# Run with output
ctest --verbose
```

**C# Unit Tests (xUnit/NUnit):**
```bash
# Find test projects
find . -name "*.Tests.csproj"

# Run tests via dotnet
dotnet test src/GifBolt.Core.Tests/GifBolt.Core.Tests.csproj -c Release
dotnet test --verbosity normal  # Show test names

# Test with coverage
dotnet test --collect:"XPlat Code Coverage"
```

**Test Coverage:**
- C++: Catch2 tests in `tests/` directory
- C#: xUnit tests in `GifBolt.*.Tests` projects
- Run before commit to ensure regressions are caught

**Performance/Profiling Tests:**
```bash
# C++ benchmarks (scale, threading, rendering)
build/tests/GifBolt.Tests ScalingFilterBenchmarks.cpp
build/tests/GifBolt.Tests ThreadPoolBenchmarks.cpp
build/tests/GifBolt.Tests GPUProfilingTests.cpp

# Compare before/after optimization
time ./debug_gif_delays /path/to/large.gif
```

---

## Related Files

`.editorconfig`=C# style rules; `.clang-format`=C++ formatting; `.clang-tidy`=C++ static analysis; `CMakeLists.txt`=build config; `.pre-commit-config.yaml`=pre-commit validation

Apply include-what-you-use; don't commit commented code-fix if possible; copyright headers important; WPF/Avalonia=same feature set; bundle as NuGet; C++ code=clang-tidy compliant

To build for X64

cmake -G "Visual Studio 18 2026" -A x64 -B build
cmake --build build --config Release
& "C:\Dev\Perso\gifbolt\deploy-dlls.ps1"